<?php

namespace Famoser\Elliptic\ConstTime\Collectors;

use Famoser\Elliptic\Integration\Utils\ECDSASigner;
use Famoser\Elliptic\Integration\WycheProof\Utils\FixturesRepository;
use Famoser\Elliptic\Integration\WycheProof\Utils\WycheProofConstants;
use Famoser\Elliptic\Math\MathInterface;

class EcdsaSha256WycheProofCollector
{
    private ECDSASigner $signer;
    private array $fixtures;
    private array $results;

    public function __construct(private readonly string $curveName, private readonly MathInterface $math)
    {
        $fixtures = FixturesRepository::createEcdsaSha256Fixtures($this->curveName);
        $this->fixtures = array_filter($fixtures, function (array $fixture) {
            return $fixture['result'] === WycheProofConstants::RESULT_VALID;
        });
        $this->results = [];
        foreach ($this->fixtures as $key => $fixture) {
            $this->results[$key] = [];
        }

        $this->signer = new ECDSASigner($math, 'sha256');
    }

    public function collect(): void
    {
        $execution = count($this->results[array_key_first($this->results)]);
        $order = $this->deterministicallyRandomizeArray($execution, array_keys($this->fixtures));
        foreach ($order as $index => $key) {
            $fixture = $this->fixtures[$key];
            $publicKey = $fixture['publicKey'];
            $signature = $fixture['sig'];
            $message = $fixture['message'];

            $start = microtime(true);
            $this->signer->verify($publicKey, $signature, $message);
            $end = microtime(true);

            $this->results[$key][] = ['index' => $index, "time" => $end - $start];
        }
    }

    /**
     * the point is just to avoid branch predictors, caching to have too much of an influence
     * the randomization needs to however not be "cryptographically" random

     * hence code generated by some AI; manually checked that the arrays "look" random
     * the magic numbers seem to be "inspired" by a suboptimal c random implementation
     * but sufficient for our cases
     */
    private function deterministicallyRandomizeArray(int $iteration, array $values): array
    {
        $seed = $iteration;
        for ($i = count($values) - 1; $i > 0; $i--) {
            $j = ($seed ^ $i) % ($i + 1);

            $temp = $values[$i];
            $values[$i] = $values[$j];
            $values[$j] = $temp;

            $seed = ($seed * 1103515245 + 12345) & 0x7fffffff;
        }

        return $values;
    }

    public function store(): array
    {
        $samples = [];
        foreach ($this->results as $key => $result) {
            $fixture = $this->fixtures[$key];
            $samples[] = [
               "id" => $key,
                "flags" => $fixture['flags'],
                "measurements" => $result,
            ];
        }

        return [
            'math' => $this->math::class,
            'curve' => $this->curveName,
            'samples' => $samples
        ];
    }
}
