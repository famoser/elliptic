<?php

namespace Famoser\Elliptic\ConstTime\Collectors;

use Famoser\Elliptic\Integration\Rooterberg\FixturesRepository;
use Famoser\Elliptic\Integration\Utils\ECDSASigner;
use Famoser\Elliptic\Integration\WycheProof\Utils\WycheProofConstants;
use Famoser\Elliptic\Math\MathInterface;

class EcdsaSha256ProofCollector implements ProofCollectorInterface
{
    private array $results;

    public function __construct(private readonly string $curveName, private readonly ECDSASigner $signer, private readonly MathInterface $math, private readonly array $fixtures)
    {
        $this->results = [];
        foreach ($this->fixtures as $key => $fixture) {
            $this->results[$key] = [];
        }
    }

    public function getCurveName(): string
    {
        return $this->curveName;
    }

    public function getMath(): MathInterface
    {
        return $this->math;
    }

    public function collect(): void
    {
        $execution = count($this->results[array_key_first($this->results)]);
        $order = $this->deterministicallyRandomizeArray($execution, array_keys($this->fixtures));
        foreach ($order as $index => $key) {
            $fixture = $this->fixtures[$key];
            $publicKey = $fixture['publicKey'];
            $signature = $fixture['sig'];
            $message = $fixture['message'];

            $start = microtime(true);
            $this->signer->verify($publicKey, $signature, $message);
            $end = microtime(true);

            $this->results[$key][] = ['index' => $index, "time" => $end - $start];
        }
    }

    /**
     * to avoid branch predictors & caching to have too much of an influence
     * we randomize the order of the array
     * in a deterministic way to make the measurements reproducible
     *
     * as the target is just to confuse caching
     * randomization needs to however not be "cryptographically" random
     * hence we use some code generated by some AI
     *
     * we manually checked that the arrays "look" random
     * the magic numbers seem to be "inspired" by a suboptimal c random implementation
     */
    private function deterministicallyRandomizeArray(int $iteration, array $values): array
    {
        $seed = $iteration;
        for ($i = count($values) - 1; $i > 0; $i--) {
            $j = ($seed ^ $i) % ($i + 1);

            $temp = $values[$i];
            $values[$i] = $values[$j];
            $values[$j] = $temp;

            $seed = ($seed * 1103515245 + 12345) & 0x7fffffff;
        }

        return $values;
    }

    public function store(): array
    {
        $samples = [];
        foreach ($this->results as $key => $result) {
            $fixture = $this->fixtures[$key];
            $samples[] = [
                "id" => $key,
                "flags" => $fixture['flags'],
                "measurements" => $result,
            ];
        }

        return [
            'math' => $this->math::class,
            'curve' => $this->curveName,
            'samples' => $samples
        ];
    }
}
