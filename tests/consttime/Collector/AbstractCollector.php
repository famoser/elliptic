<?php

namespace Famoser\Elliptic\Tests\ConstTime\Collector;

abstract class AbstractCollector implements CollectorInterface
{
    private array $results;

    public function __construct(private readonly string $curveName, private readonly string $mathName, private readonly array $fixtures)
    {
        $this->results = [];
        foreach ($this->fixtures as $key => $fixture) {
            $this->results[$key] = [];
        }
    }

    public function getCurveName(): string
    {
        return $this->curveName;
    }

    public function getMathName(): string
    {
        return $this->mathName;
    }

    public function collect(): void
    {
        $execution = count($this->results[array_key_first($this->results)]);
        $order = $this->deterministicallyRandomizeArray($execution, array_keys($this->fixtures));
        foreach ($order as $index => $key) {
            $fixture = $this->fixtures[$key];

            $start = microtime(true);
            $this->runFixture($fixture);
            $end = microtime(true);

            $this->results[$key][] = ['index' => $index, "time" => $end - $start];
        }
    }

    /**
     * to avoid branch predictors & caching to have too much of an influence
     * we randomize the order of the array
     * in a deterministic way to make the measurements reproducible
     *
     * as the target is just to confuse caching
     * randomization needs to however not be "cryptographically" random
     * hence we use some code generated by some AI
     *
     * we manually checked that the arrays "look" random
     * the magic numbers seem to be "inspired" by a suboptimal c random implementation
     */
    protected function deterministicallyRandomizeArray(int $iteration, array $values): array
    {
        $seed = $iteration;
        for ($i = count($values) - 1; $i > 0; $i--) {
            $j = ($seed ^ $i) % ($i + 1);

            $temp = $values[$i];
            $values[$i] = $values[$j];
            $values[$j] = $temp;

            $seed = ($seed * 1103515245 + 12345) & 0x7fffffff;
        }

        return $values;
    }

    public function store(): array
    {
        $samples = [];
        foreach ($this->results as $key => $result) {
            $fixture = $this->fixtures[$key];
            $samples[] = [
                "id" => $key,
                "flags" => $fixture['flags'],
                "measurements" => $result,
            ];
        }

        return [
            'math' => $this->mathName,
            'curve' => $this->curveName,
            'samples' => $samples
        ];
    }

    abstract protected function runFixture(array $fixture): void;
}
